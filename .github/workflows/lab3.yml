name: "Lab 3 • Chained Jobs with Outputs"
run-name: "Lab 3 • ${{ github.actor }} • run #${{ github.run_number }} • env=${{ inputs.environment }}"
 
on:
  # Manual trigger with inputs
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment (dev/staging/prod)"
        type: choice
        required: true
        default: main
        options:
          - main
          - staging
          - prod
      appName:
        description: "Application name (used to compute IDs)"
        type: string
        required: true
        default: "lkkiara-web"
      buildNumber:
        description: "Optional build number override"
        type: number
        required: false
      region:
        description: "Deployment region (just a label in this lab)"
        type: choice
        required: true
        default: centralindia
        options:
          - centralindia
          - eastus
          - westus2
 
  # Optional: also run on push to master if you want
  push:
    branches: [ main ]
    paths:
      - ".github/workflows/lab3.yml"
 
jobs:
  job1_generate_ids:
    name: "Job 1 • Generate IDs"
    runs-on: ubuntu-latest
 
    outputs:
      env_slug: ${{ steps.make.outputs.env_slug }}
      app_id: ${{ steps.make.outputs.app_id }}
      effective_build_number: ${{ steps.make.outputs.effective_build_number }}
 
    steps:
      - name: "Checkout"
        uses: actions/checkout@v4
 
      - name: "Compute derived values from inputs"
        id: make
        run: |
          # Normalize environment for safe usage
          ENV_SLUG=$(echo "${{ inputs.environment }}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')
 
          # App ID composed from appName + environment
          APP_ID="${{ inputs.appName }}-${ENV_SLUG}"
 
          # Use the provided buildNumber if set, else fall back to GitHub run number
          if [ -n "${{ inputs.buildNumber }}" ]; then
            EFFECTIVE_BUILD="${{ inputs.buildNumber }}"
          else
            EFFECTIVE_BUILD="${{ github.run_number }}"
          fi
 
          echo "env_slug=$ENV_SLUG" >> "$GITHUB_OUTPUT"
          echo "app_id=$APP_ID" >> "$GITHUB_OUTPUT"
          echo "effective_build_number=$EFFECTIVE_BUILD" >> "$GITHUB_OUTPUT"
 
      - name: "Display outputs (for demo)"
        run: |
          echo "env_slug=${{ steps.make.outputs.env_slug }}"
          echo "app_id=${{ steps.make.outputs.app_id }}"
          echo "effective_build_number=${{ steps.make.outputs.effective_build_number }}"
 
  job2_prepare_release:
    name: "Job 2 • Prepare Release"
    runs-on: ubuntu-latest
    needs: [ job1_generate_ids ]  # depends on job 1
 
    outputs:
      release_tag: ${{ steps.tag.outputs.release_tag }}
      artifact_name: ${{ steps.tag.outputs.artifact_name }}
 
    steps:
      - name: "Checkout"
        uses: actions/checkout@v4
 
      - name: "Use Job 1 outputs to craft release tag & artifact names"
        id: tag
        run: |
          ENV_SLUG="${{ needs.job1_generate_ids.outputs.env_slug }}"
          APP_ID="${{ needs.job1_generate_ids.outputs.app_id }}"
          BUILD_NO="${{ needs.job1_generate_ids.outputs.effective_build_number }}"
 
          # Release tag format: <env>/<app>/<build>
          RELEASE_TAG="${ENV_SLUG}/${APP_ID}/${BUILD_NO}"
 
          # Artifact name example
          ARTIFACT_NAME="${APP_ID}-build-${BUILD_NO}.zip"
 
          echo "release_tag=$RELEASE_TAG" >> "$GITHUB_OUTPUT"
          echo "artifact_name=$ARTIFACT_NAME" >> "$GITHUB_OUTPUT"
 
      - name: "Show computed values"
        run: |
          echo "release_tag=${{ steps.tag.outputs.release_tag }}"
          echo "artifact_name=${{ steps.tag.outputs.artifact_name }}"
 
      # (Optional) you could build and upload an artifact here
      # - name: "Upload dummy artifact"
      #   run: |
      #     echo "This could be your build output." > dummy.txt
      #     zip "${{ steps.tag.outputs.artifact_name }}" dummy.txt
      #   shell: bash
      # - uses: actions/upload-artifact@v4
      #   with:
      #     name: "${{ steps.tag.outputs.artifact_name }}"
      #     path: "${{ steps.tag.outputs.artifact_name }}"
 
  job3_deploy:
    name: "Job 3 • Deploy"
    runs-on: ubuntu-latest
    needs: [ job2_prepare_release ]  # depends on job 2
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
 
    steps:
      - name: "Checkout"
        uses: actions/checkout@v4
 
      - name: "Read inputs and prior job outputs"
        run: |
          ENVIRONMENT="${{ inputs.environment }}"
          REGION="${{ inputs.region }}"
          APP_ID_FROM_JOB1="${{ needs.job1_generate_ids.outputs.app_id }}"
          RELEASE_TAG_FROM_JOB2="${{ needs.job2_prepare_release.outputs.release_tag }}"
          ARTIFACT_NAME_FROM_JOB2="${{ needs.job2_prepare_release.outputs.artifact_name }}"
 
          echo "Deploying:"
          echo "  environment: $ENVIRONMENT"
          echo "  region:      $REGION"
          echo "  app_id:      $APP_ID_FROM_JOB1"
          echo "  release_tag: $RELEASE_TAG_FROM_JOB2"
          echo "  artifact:    $ARTIFACT_NAME_FROM_JOB2"
 
      # (Optional) Here you'd run cloud CLI to deploy using these values
      # e.g., az webapp deployment, terraform apply, bicep deployment, etc.
      - name: "Simulate deploy"
        run: |
          echo "Simulating deployment for ${{ inputs.appName }} in ${{ inputs.environment }} (${{ inputs.region }})"
          echo "Using release tag: ${{ needs.job2_prepare_release.outputs.release_tag }}"
          echo "Success ✅"
